@startuml
participant Client1
participant Client2
participant ThreadPool
participant "Task1" as T1
participant "Task2" as T2
participant "Task3" as T3
participant "Task4" as T4
participant "Task5" as T5
participant "Task6" as T6

activate Client1
Client1 -> ThreadPool : postTask(T1)
activate ThreadPool
Client1 -> ThreadPool : postTask(T2)
Client1 -> ThreadPool : postTask(T3)
ThreadPool -> T1 : allocate()
activate T1
ThreadPool -> T2 : allocate()
activate T2
ThreadPool -> T3 : allocate()
activate T3

note over T1, T3
After some time, all three allocated
threads post work back to the ThreadPool
end note
T1 -> ThreadPool : postTask(T4)
ThreadPool -> T1 : return fut4

T2 -> ThreadPool : postTask(T5)
ThreadPool -> T2 : return fut5

T3 -> ThreadPool : postTask(T6)
ThreadPool -> T3 : return fut6


activate Client2
Client2 -> ThreadPool : Unregister()
note over ThreadPool : Unregister must be called before\nTasks 4, 5, and 6 are allocated
deactivate ThreadPool
T1 -> T4 : fut4.get()
T2 -> T5 : fut5.get()
T3 -> T6 : fut6.get()

note over T4, T6
These threads are never allocated
because they were posted succesfully
but cleared from the queue on destruction
of the ThreadPool
end note

@enduml